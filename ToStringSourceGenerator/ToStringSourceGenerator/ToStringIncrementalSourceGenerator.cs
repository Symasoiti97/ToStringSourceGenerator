using System;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;


namespace ToStringSourceGenerator;

/// <summary>
/// A source code generator that overrides the toString method, which returns the names and values of class properties.
/// The target class should be annotated with the 'Generators.ToStringAttribute' attribute.
/// </summary>
[Generator]
public sealed class ToStringIncrementalSourceGenerator : IIncrementalGenerator
{
    private const string Namespace = "Generators";
    private const string AttributeName = "ToStringAttribute";

    private const string AttributeSourceCode = $$"""
                                                 // <auto-generated/>

                                                 namespace {{Namespace}}
                                                 {
                                                     [System.AttributeUsage(System.AttributeTargets.Class)]
                                                     public sealed class {{AttributeName}} : System.Attribute
                                                     {
                                                     }
                                                 }
                                                 """;


    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Add the marker attribute to the compilation.
        context.RegisterPostInitializationOutput(ctx => ctx.AddSource(
            $"{AttributeName}.g.cs",
            SourceText.From(AttributeSourceCode, Encoding.UTF8)));

        // Filter classes annotated with the [ToString] attribute. Only filtered Syntax Nodes can trigger code generation.
        var provider = context.SyntaxProvider
            .CreateSyntaxProvider(
                (s, _) => s is ClassDeclarationSyntax,
                (ctx, _) => GetClassDeclarationForSourceGen(ctx))
            .Where(t => t.HasToStringAttribute)
            .Select((t, _) => t.Syntax);

        // Generate the source code.
        context.RegisterSourceOutput(context.CompilationProvider.Combine(provider.Collect()),
            ((ctx, t) => GenerateCode(ctx, t.Left, t.Right)));
    }

    /// <summary>
    /// Checks whether the Node is annotated with the [ToString] attribute and maps syntax context to the specific node type (ClassDeclarationSyntax).
    /// </summary>
    /// <param name="context">Syntax context, based on CreateSyntaxProvider predicate</param>
    /// <returns>The specific cast and whether the attribute was found.</returns>
    private static (ClassDeclarationSyntax Syntax, bool HasToStringAttribute) GetClassDeclarationForSourceGen(
        GeneratorSyntaxContext context)
    {
        var classDeclarationSyntax = (ClassDeclarationSyntax) context.Node;

        // Go through all attributes of the class.
        foreach (var attributeSyntax in classDeclarationSyntax.AttributeLists
                     .SelectMany(attributeListSyntax => attributeListSyntax.Attributes))
        {
            if (ModelExtensions.GetSymbolInfo(context.SemanticModel, attributeSyntax).Symbol is not IMethodSymbol
                attributeSymbol)
                continue; // if we can't get the symbol, ignore it

            var attributeName = attributeSymbol.ContainingType.ToDisplayString();

            // Check the full name of the [ToString] attribute.
            if (attributeName == $"{Namespace}.{AttributeName}")
                return (classDeclarationSyntax, HasToStringAttribute: true);
        }

        return (classDeclarationSyntax, HasToStringAttribute: false);
    }

    /// <summary>
    /// Generate code action.
    /// It will be executed on specific nodes (ClassDeclarationSyntax annotated with the [ToString] attribute) changed by the user.
    /// </summary>
    /// <param name="context">Source generation context used to add source files.</param>
    /// <param name="compilation">Compilation used to provide access to the Semantic Model.</param>
    /// <param name="classDeclarations">Nodes annotated with the [ToString] attribute that trigger the generate action.</param>
    private void GenerateCode(SourceProductionContext context,
        Compilation compilation,
        ImmutableArray<ClassDeclarationSyntax> classDeclarations)
    {
        // Go through all filtered class declarations.
        foreach (var classDeclarationSyntax in classDeclarations)
        {
            if (TryBuildClassText(compilation, classDeclarationSyntax, out var code, out var className))
            {
                // Add the source code to the compilation.
                context.AddSource($"{className}.g.cs", SourceText.From(code!, Encoding.UTF8));
            }
        }
    }

    // TODO: Refactor and add error logging to build console
    private static bool TryBuildClassText(
        Compilation compilation,
        ClassDeclarationSyntax classDeclarationSyntax,
        out string? code,
        out string? className)
    {
        code = null;
        className = null;

        // We need to get semantic model of the class to retrieve metadata.
        var semanticModel = compilation.GetSemanticModel(classDeclarationSyntax.SyntaxTree);

        // Symbols allow us to get the compile-time information.
        if (ModelExtensions.GetDeclaredSymbol(semanticModel, classDeclarationSyntax) is not INamedTypeSymbol
            classSymbol)
        {
            return false;
        }

        const string innerCodeKey = "%InnerCode%";
        var innerClasses = innerCodeKey;
        var parent = classDeclarationSyntax.Parent;
        while (parent is ClassDeclarationSyntax parentClass)
        {
            if (parentClass.Modifiers.Any(SyntaxKind.PartialKeyword))
            {
                var outerClass = $$"""
                                   {{parentClass.Modifiers.ToString()}} class {{parentClass.Identifier.Text}}
                                   {
                                         {{innerCodeKey}}
                                   }
                                   """;

                innerClasses = outerClass.Replace(innerCodeKey, innerClasses);
            }
            else
            {
                return false;
            }

            parent = parentClass.Parent;
        }

        var namespaceName = classSymbol.ContainingNamespace.ToDisplayString();

        // 'Identifier' means the token of the node. Get class name from the syntax node.
        className = classDeclarationSyntax.Identifier.Text;

        // Go through all class members with a particular type (property) to generate method lines.
        var properties = classSymbol.GetMembers()
            .OfType<IPropertySymbol>()
            .Select(p =>
            {
                var propertyValue = p.Type.OriginalDefinition.Name == nameof(String) || p.Type.IsValueType
                    ? p.Name
                    : $"{p.Name}?.ToString()";

                return $"{p.Name} = {{this.{propertyValue}}}";
            })
            .ToArray(); // e.g. yield return $"Number = {this.Number}";

        var methodBody = $$$"""return $"{{{className}}} {{ {{{string.Join(", ", properties)}}} }}";""";

        // Build up the source code
        code = $$"""
                 // <auto-generated/>

                 using System;
                 using System.Collections.Generic;

                 namespace {{namespaceName}};

                 {{innerClasses.Replace(innerCodeKey, $$"""
                                                        public partial class {{className}}
                                                        {
                                                            public override string ToString()
                                                            {
                                                                {{methodBody}}
                                                            }
                                                        }
                                                        """)}}

                 """;

        return true;
    }
}
